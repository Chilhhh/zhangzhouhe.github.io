[{"id":"560a8d7b89281af7acdccb88ab5d1e34","title":"Java note","content":"JAVA NOTE\n[TOC]\nTeaching Block11.phase of java programphase1: Edit(by editor ):  Every java program have the extensing .java\nphase2: Compile(编译器): \n\n\n\n\n\n\n\n\n\ntranslates your program into bytecode so that the Java interpreter can read the   program（MyProgram.class）                     \njavac Myprogram.java\n\nPhase 3: Load + Phase 4: Verify\n\n\n\n\n\n\n\n\n\nloading into memory\njava MyProgram\n\nPhase 5: Execute\nThe file name and the class name must be the same. \nMyProgram.java\n\nTo compile the program, type (with file extension编译时加后缀):\njavac MyProgram.java\n\nTo run the program, type (without file extension运行不加后缀):\njava MyProgram\n\nThe interpreter executes main first.\n1.1.补充1.常见dos命令\n\n\n\n1.2.补充2.main method\n\n\n\n2.Basic data types（基本数据类型、引用数据类型）2.1.introduction\n\n\n\n\n\n\n\n\n   Java is strongly typed and strongly classed– Only variables with the same types or classes can be used together.\n\n\nEvery data type in Java has a default value\n\n\n\n\n\n\n\n\n\n\n\nlong类型在数字后面加L否则整数默认为int类型\n\n\n\n\n\n\n\n\n\nfloat 加F 否则小数默认为 double类型\n2.2.补充1.变量命名规则\n\n\n\n2.3.补充2.类型转换 自动类型转换：范围小的数赋值给范围大的数\n强制类型转化(type cast operator.) ：范围大的数赋值给范围小的数\nint k=(int)88.8\n\n  Conversion between numeric types:\n\n\n\n\n\n\n\n\n\nbyte &#x3D;&gt; short &#x3D;&gt; int &#x3D;&gt; long &#x3D;&gt; float &#x3D;&gt; double\n​                                         \n3.Operators3.1.introduction\nIncrements and Decrements\n\n\n\n\n\n\n\n\n\n\n\n\n– A post operation causes the variable to first be used  in the current statement, and then it is incremented or decremented afterwards.\n\n\n\n\n\n\n\n\n\n– A pre operation causes the variable to first be incremented or decremented, and then it is used in the current statement.\n\nOperator Precedence(优先级)\n\n\n\n\nRelational Operations\n\n\n\n\nLogical operators\n\n\n\n\nswitch statement\n\n\n\n\n\n\n\n\n\n\n\n\nbreak – causes the remainder of the **switch **statement to be skipped\n\n\n\n\n\n\n\n\n\ndefault – action in case none of the cases match\n\nConditional Operator\n\n\n\n\nThe break and continue statements\n\n​         break——quitting the loop\n​         continue——skipping the current iteration\n​      补充:Using labelled statement blocks with break and continue\nouter:\n    for (int i=1; i&lt;5; i++) &#123;\n      System.out.println(\"Begin outer for i=\" + i); \ninner:\n      for (int j=1; j&lt;5; j++) &#123;\n        if (j == i) break outer;\n      &#125;\n      &#125;\n\nouter:\n   for (int i=1; i&lt;5; i++) &#123;\n     System.out.println(\"Begin outer for i=\" + i); \ninner:\n     for (int j=1; j&lt;5; j++) &#123;\n       if (j == i) continue;\n  System.out.println(\"   inner: i=\" + i + \" j=\" + j);\n     &#125;\n     System.out.println(\"End outer for i=\" + i); \n   &#125; \n\n3.2.IDEA使用\n项目结构：模块-包-java类\n\n\n\n快捷键\n\n\n\n4. OO programming and objects4.1.introduction\nWhat is OO programming?\n\n\n\n\n\n\n\n\n\n\nConstructing software systems which are structured collections(or sets) of classes.\n These classes produce instances called objects\n\nWhat is object?Objects are things or nouns.\n\nAttributes (or states) of an object:\n\n\n\n\n\n\n\n\nessentially anything that describes or quantifies an object. \n\nOperations (or behaviours) of an object:\n\n\n\n\n\n\n\n\nthey mostly correspond to verbs in a requirements specification.\n\n\n The class defines the attributes and operations exposed by one or more related objects\n\nWhat is a class?\n\n​     An object is an instance of a particular class, We can split up code between different objects.\n\nUML Class diagram notation\nUML &#x3D; Unified Modelling Language\n\n\n\n4.2.Methods\n\nsyntax\n\nmodifiers returnType methodName(parameters) &#123;\nstatements;\n&#125;\n\n\n\nA method uses parameters&#x3D;形参(formal parameter), whereas the caller passes arguments&#x3D;实参(actual parameter).\n\nCalling(调用) a method\n\n\n\n\n\n\nPass-by-value（Pass-by-copy）\n\n\n\n\n\n\n\n\n在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。\n\nMethod OverloadingJava allows several methods to be defined with the same name, as long as they have different sets of parameters\n&#x3D;&#x3D;The return type is NOT used to differentiate methods&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n\n\n\n只有参数类型有关,与返回值类型无关               \n4.3.Create a class\n\n\n\n\n\n\n\n\ninstance variable(成员变量)+instance method（成员方法）+constructors（构造方法）\nattribute——instance variable    ， operation——instance method\n\nclass XXX&#123;\n  int attribute1=1;\n  double attribute2=2;\n  //instance variable\n  \n   XXX(int xxx)&#123;\n        \n    &#125;\n   //constructors\n    \n    double opeartion1()&#123;\n        \n    &#125;\n    int opeartion2()&#123;\n        \n    &#125;\n   //instance method\n&#125;\n\n\ncreate a object\n\nclassName objectName=new className();\n\n\n\n\n\n\n\n\n\n\nA  object is a reference variable. \n\nUsing instance variables and methods\n\n– to access a (public) instance variable v of an object o, we reference it using the dot notation*:*\no.v\n\n– to invoke a (public) method m of an object o, we also reference it using the dot notation:\no.m()\n\n\nConstructorsA constructor is a special method, with same name as the class name, used for initialisation.\n\n\n\n\n\n\n\n\n\n\nIt does not have a return type, not even void!\n An empty no-argument constructor is provided for you by Java(如果没有自定义，系统会自带一个无参构造方法，如果自己写了构造方法，系统将不提供无参构造方法)。\n\npublic Cat() &#123;\n\n&#125;\n\n\nData Encapsulation(对成员变量封装)\n\nThis is a good thing! Since objects are only accessible through well defined interfaces, ideally nothing unexpected should happen!\n\n\n\n\n\n\n\n\n\nWe should NOT allow direct access to an object’s variables.\n\n\n\n\n\n\n\n\n\nAny changes to the object’s state (i.e. its variables) should be made ONLY by that object’s methods\n把成员变量定义加private，并且添加两个method实现访问和更改变量\naccessor(访问器)：get方法——getXxx()\nmutator(修改器)：set方法——setXxx()\nAll getters and setters should have names that conform to the following:\n&#x3D;&#x3D;variableType getVariableName()&#x3D;&#x3D; \n&#x3D;&#x3D;void setVariableName(VariableType)&#x3D;&#x3D;\npublic void setAge(int age)&#123;\n       this.age=age;\n   &#125;\n \npublic int getAge()&#123;\n       return age;\n   &#125;\n\n\nthis引用this 是指向对象本身的引用名，利用this引用对象的instance variable\n\npublic void setAge(int age)&#123;\n      this.age=age;\n  &#125;\n\n\n\n\n\n\n\n\n\n\n不加this指代parameters, 加this指代instance variable\n补充：this（）可以用来同类的另一个构造方法\nPerson(String nm) &#123;\n        name &#x3D; nm;\n    &#125;\nPerson(String nm, int a) &#123;\n        this(nm);\n        age &#x3D; a;\n    &#125;\n\n\n\ntoString() methodThis method returns a String representation of the object.\npublic String toString() &#123;\nreturn “Account number: ” + accNo + “\\n” \n+ “Account name: ” + accName + “\\n”\n+ “Balance: ” + balance ;\n&#125;\n\n它通常只是为了方便输出,在main中需要输出class的变量时，直接使用：\nSystem.out.println(classname);\n\n等同于\nSystem.out.println(classname.toString);\n\n4.4.Method parameters 、 local variables、instance variables\n\n\n\n\n\n\n\n\nMethod parameters are virtually the same as local variables!\n– They are declared inside the method.\n– They are valid (or in scope) only inside the method.\n– They are always initialised (by the caller of the method).必须初始化\n\nInitialisation（变量初始化） Java automatically sets some initial values for you for variables of the class (instance variables), but not for variables in methods\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTeaching Block21.ArraysArrays provide fast random access by letting you use an index position to get any element in the array.\n\n\n\n\n\n\n\n\n\nArrays must be given a size! \nStandard arrays cannot grow and shrink in size\n\n\n动态初始化：\n只指定数组的长度\n\n\nAn array is an object, even though it may be an array of primitives.\n\nArray elements can be either primitives or objects.\n\nThe main() method has the Array of Strings.\n\n\npublic static void main(String[] args) \n\n数组的长度：array.length\n1.1.copy arrayreference copy: Only copies the reference value!\nRabbit[] racers2;\n\nracers2 = racers;\n\ncopy the data type variables:\n\nUse a loop to copy all individual elements.\n\nUse the static arraycopy method in the System class\n\n\n\nsrc is the array to copy from; dest is the array to copy to\n• srcPos is where in the src array to start copying from.\n• destPos is where, in the dest array, to start putting the newly copied \nelements\n1.2.Passing Arrays to MethodsJava uses pass-by-value, to pass arguments to a method(only have pass by value)\n\n\n\n\n\n\n\n\n\nJava passes (to the method) a copy of the reference variable to the array object \n数组作为方法参数—传递地址\n1.3.“Prep code”\n\n\n\n\n\n\n\n\nA form of pseudocode, to help focus on the logic without the worry of syntax\n2.Stringjava 中的所有双引号中都为字符串。\n\nstring 特点：\n\n\n\n\n\n\n\n\n\nString对象不可变\n\n\nString s=\"java\";\ns=\"html\";\n\n不能改变s的值\n\nstring构造方法：\n\n\n两种创建字符串的方法：\n通过new创建对象，每次都会申请一个新的内存空间。\n以”“创建对象如果内容一样，则jvm只会创建一个String对象\nString st1=new String(ch2);\n       String st2=new String(ch2);\n       System.out.println(st1==st2);\n   //new构建时，st1与st2地址不同\n  \n       String st3=\"abc\";\n       String st4=\"abc\";\n       System .out .println(st3==st4);\n       //直接赋值时，st3与st4的地址相同\n\n字符串的比较\n\nstring1.equals(string2)\n\n\n字符串相加：\n\nSystem.out.println(\"aaa\"+1+1);\n\n输出 aaa11\nSystem.out.println(\"aaa\"+(1+1));\n\n输出 aaa2\n\n字符串转字符\n\n\n\n字符串长度\n\n\n\n3.StringBuilder\n\n\n\n\n\n\n\n\n可变字符串\n\n构造方法\n\n\n\n添加和反转\n\n\n返回值是本身的类，所以可以链式编程\n\n与String的转换\n\n\n4.ArrayListArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。\nArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下：\nimport java.util.ArrayList; // 引入 ArrayList 类\n\nArrayList&lt;E> objectName =new ArrayList&lt;E>();　 // 初始化\n\n\n\n\n\n\n\n\n\n\nE: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。\n4.1.Some ArrayList methods常用的method：\n\n\n Find out if it contains something:\nboolean inIt = myList.contains(f);\n\nFind out where in the list something is:\nint index = myList.indexOf(f);\n\nFind out if the list is empty:\nboolean empty = myList.isEmpty();\n\nArrayList字符串遍历的基本格式：\n\n5.Inheritance and Abstract classes5.1.two primary types of relationships between classes– aggregation (referred as has-a)\n– inheritance (referred as is-a)\n5.2.Inheritance\n\n\n\n\n\n\n\n\nvia the extends keyword\n\n\n Subclasses inherit the properties (attributes and operations) of their superclass.\n\n\nTo provide specialisations, subclasses &#x3D;&#x3D;override&#x3D;&#x3D; methods that they inherit from the superclass\n父类的私有数据域在子类中仍是不能访问的。java中只支持单一继承。\n构造方法不会被继承\nAccess Modifiers（可访问修饰符）\n\n\npublic\n\n– public instance variables and methods are inherited\n• protected\n– protected instance variables and methods are inherited\n• private\n– any private instance variables and methods\nare not inherited and cannot be seen by the subclass\n5.2.1.override\n方法重写时建议加注解@Override以区分是否为重写还是新子类方法\n\n\n5.2.2.super的使用super用于指代父类，可以调用父类中的普通方法和构造方法\n调用普通方法类似于this的语法：super.方法名（参数）；\n调用父类的构造方法\n\n每个子类构造方法执行的第一步都为隐式调用（先访问父类的无参构造方法）所以每个父类一定要重载无参构造方法。\nthis指本类，super指代父类。\n\n\n5.2.3.成员方法访问的特点\n\n\n\n\n5.2.4.final和static关键字\n\n\n\n\n\n\n\npublic static int a;\n\n任意一个对象给a赋值之后所有对象共享a的值。\n一般对static修饰的变量访问时使用\n类名.变量名&#x3D;xxxx;\n使用类名对此变量统一赋值。\nstatic修饰方法：（静态方法可以被继承，不能被重写）\n\n\n5.3.PolymorphismPolymorphism ：Using a single definition (superclass) with different types (subclass)\n（父类变量指向子类对象）\nCreature c = new Rabbit();\n\n\n\n\n\nobject o=new student();\n\n其中object是o的声明类，student是o的实际类，o调用方法时由实际类型决定。\n访问时要先看左边（声明类）中有无此变量或对象，如果有才可以执行。\n执行方法时执行的是右边（实际类）的重写方法，执行变量时是执行声明类中的变量。\n多态中的对象转换：\n\n\n向上转型\nobject o&#x3D;new student();\n向下转换（强制）– Explicit cast\nstudent b&#x3D;(student)o;\n5.4.java的object类中常用方法：\n\n\n\n\n\n\n\n\njava.lang.Object is the ultimate parent of EVERY class in java\nSome methods of the “object” class\n\n\n\n\n\n\n\n\n\nequals() determines when one object is equal to another\n未重写：09\n+k+判断两类的地址是否相同\n在类中重写equals()判断两个类内容是否相等。\n\n\n\n\n\n\n\n\n\ntoString() allows objects to be printed\n输出：类名@加地址\n重写toString()打印类中信息\n\n\n\n\n\n\n\n\n\nhashCode() is a unique ID for every object, usually based on its memory address\n\n\n\n\n\n\n\n\n\ngetClass() returns the class of the object返回类名\n5.5.abstract classThe compiler will not let you instantiate an abstract class.\n– The only use it has is in being extended\n A non-abstract class is called a concrete class.\n• abstract in terms of classes  that class must be extended, in \norder to be instantiated\n• abstract for methods   the method must be overridden in the \nchild class\n\n\n\n\n\n\n\n\n\nsubclass must implement ALL abstract methods from its superclass (or be declared abstract).\n\n\n抽象方法：\npublic abstract void eat();\n\n\n\n\n\nTeaching Block31.interface接口是一种与类类似的结构，只能包含常量和抽象方法。\n无构造方法\n\nBefore Java SE8, interfaces could have:\n\nconstant fields (public static可以省略)(引用时使用父类接口作为前缀Father.age)\npublic static final int x = 10;\n\nabstract methods （public abstract可以省略）\npublic abstract void doStuff();\n\n\nFrom Java SE8, interfaces can also have:\n\n\n\n\n\n\n\n\n\n\ndefault methods  Allow developers to add new functionality to interfaces, without impacting any existing classes that are already implementing the interface.用了default关键字修饰方法之后，这个方法是可以有方法体\n&#x3D;&#x3D;Can be overridden in the class that implements the interface.&#x3D;&#x3D;Provide backward compatibility(向后兼容) for existing interfaces.\n\n\n\n\n\n\n\n\n\nstatic methods  Allow developers to define utility methods in the interface（不可被重写）\n\n\n接口中\npublic interface name()&#123;&#125;\n\n类实现：\npublic class className implements interfaceName&#123;&#125;\n\n\n接口不能利用new实例化，所以必须通过类继承接口后，实例化类间接实现接口实例化\n\n\nJava’s “multiple inheritance” is at interface level only!(可以利用接口实现Java中的多继承)\npublic class className implements A,B&#123;&#125;\n\nOnly interfaces can do multiple inheritance\n\n\n\n\n\n\n\n\n多继承中如果发生两个父类有相同方法：\n\nSame named methods:\n If they have different parameters, then Child interface has both (this is same as overloading).\n\n\n​    If they differ by only return type, then error.\n​    If the two methods are identical, only keep one.\n\nSame named constants:\nwe keep both constants. To refer to them, use parent interface name as prefix\n\n\n细碎知识1.String类中的format方法format方法使用占位符进行格式化常规类型、字符类型和数值类型的占位符格式：%[index$][标识][最小宽度][.精度]转换符日期和时间类型的占位符格式：%[index$][标识][最小宽度]转换符与参数不对应的占位符格式：%[标识][最小宽度]转换符其中index表示参数列表中的位置上的值可用标识：\n\n\n\n标识\n含义\n\n\n\n-\n在最小宽度内左对齐，不可与0标识一起使用\n\n\n0\n若内容长度不足最小宽度，则在左边用0来填充\n\n\n#\n对8进制和16进制，8进制前添加一个0,16进制前添加0x\n\n\n+\n结果总包含一个+或-号\n\n\n空格\n正数前加空格，负数前加-号\n\n\n,\n只用与十进制，每3位数字间用,分隔\n\n\n(\n若结果为负数，则用括号括住，且不显示符号\n\n\n可用转换符：\n\n\n\n转换符\n含义\n\n\n\nb\n布尔类型，只要实参为非false的布尔类型，均格式化为字符串true，否则为字符串false\n\n\nn\n平台独立的换行符, 也可通过System.getProperty(“line.separator”)获取\n\n\nf\n浮点数型（十进制）。显示9位有效数字，且会进行四舍五入。如99.99\n\n\na\n浮点数型（十六进制）\n\n\ne\n指数类型。如9.38e+5\n\n\ng\n浮点数型（比%f，%a长度短些，显示6位有效数字，且会进行四舍五入）\n\n\ns\n字符串类型\n\n\nc\n字符类型\n\n\nString result1 = String.format(\"小明今年%d岁,他住在%s,他的月工资有%.2f\", 25,\"北京市\",6633.435);\nSystem.out.println(result1);//输出:小明今年25岁,他住在北京市,他的月工资有6633.44\n/*****************************************************/\ndouble num = 123.4567899;\nString result2 = String.format(\"%e\", num);\nSystem.out.println(result2);//输出：1.234568e+02\n\n2.javadocTo generate javadocdocumentation, type on the command line:\njavadoc -d docsfile.java \n\nView the docs with a web browser:\n – Start with the index.html file in the docs subdirectory.\n Java文档注释用法+JavaDoc的使用详解_阿★永的博客-CSDN博客_javadoc\n3.for 的其他语法for 的其他语法\nfor (循环变量类型 循环变量名称 : 要被遍历的对象) 循环体 \n借助这种语法，遍历一个数组的操作就可以采取这样的写法\nint[] integers = &#123;1， 2， 3， 4&#125;; \n\nfor (int i : integers) &#123; //等同于 int i;i&lt;integers;i++\n\nSystem.out.println(i);\n\n4.导包\n\n5.Sting 和int 互换字串 String 转换成整数 int\nint i = Integer.parseInt([String]);\n\n将整数 int 转换成字串 String \nString s = Integer.toString(i);\n\nString s = \"\" + i;\n\n6.scannerimport java.util.Scanner;\nScanner sc = new Scanner(System.in);\ns.nextLine()\n\n","slug":"java","date":"2022-04-18T15:03:46.000Z","categories_index":"","tags_index":"hexo","author_index":"赫"},{"id":"a5ba081d42d4ddecbbc2164f3d549c44","title":"Database note","content":"Database1.Overview of Data Models1.1.关系数据模型（Relational Model）\n\n\n\n\n\n\n\n\nA two-dimensional table called a relation\nEach relation has a name——关系名\nProvides a simple, limited approach to structuring data\nProvides a limited, yet useful, collection of operations on data\n1.1.1.Attribute(属性)The columns of a relation are named by attributes\n\n\n\n\n\n\n\n\n\nAny two attributes of a relation can’t have same name\n\n\n​                                      第一行就是每列的attribute\n1.1.2.Schemas(模式)\n\n\n\n\n\n\n\n\nRelation schema &#x3D; relation nameand the set of attributes.(关系名+属性集)\nExample:\nMovies (title, year, length, genre)\n\nMovies (title: string, year: integer, length:integer, genre: string)\n\n关系名大写开头、属性名小写开头\n数据库是collection of relations\n数据库的关系模式集合——Relational database schema\n1.1.3.Tuples (元组&#x2F;⾏)\n\n\n\n\n\n\n\n\nThe rows of a relation, other than the **header rowcontaining the attribute names,**are called tuples.\nA tuple has one **component(**属性的分量) for each attribute of the relation.\nUse commas(,)逗号 to separate components, and **use parentheses(圆括号) to surround the tuple\n\n\nExample: (‘Star Wars’, 1977, 124, ‘sciFi’)\n1.1.4.Domains（域）\n\n\n\n\n\n\n\n\nThe set of allowed values 允许的值 *for each***attribute is called the domain of the attribute\n\n\n\n\n\n\n\n\n\nAttribute values are (normally) required to be atomic, that is, indivisible.(不可分割类型)\nMovies ( title:string, year:integer, length:integer, genre:string)\n\n1.1.5.Equivalent Representations of a Relation一个给定的关系中元组的集合：Relation Instances(实例) \n属性、元组都是无序的，可以随便改变顺序但仍然为一个关系模型\nOrder of tuples is irrelevant\n1.1.6.Key\n\n\n\n\n\n\n\n\nA set of attributes forms a key for a relation if we do not allow two tuples in a relation instance to have the same values **in all the **attribute of the key.\n关系中可作键的属性集可能有多个\n1.2.Defining a Relation Schema in SQL\n\n\n\n1.2.1.SQL启动语句以及基本语法\n\n\n\n\n\n\n1.2.2.SQL分类\n1.2.3. Data Types\n\n（mysql 不区分大小写）\n\n\n\n\n\n\n\n\n\nAll attributes must have a data type.\n1.字符串\nCHAR(n)#定长字符串\n\nVARCHAR(n)#变长字符串\n\n其他：\n\n2.位串由01组成\nbit(n)#固定长度\nbit varying(n)#可变长度\n\n3.boolean\nboolean\n#可能的值有\ntrue false unknown\n\n\n4.int&#x2F;interger、浮点型\n\ndouble(2,1)#代表2位数据总长度，小数点在从右往左1的位置，如1.1\n\n\nDates and times\n\n\n\n1.2.4.定义表和表操作\n\nCREATE TABLE Salesman&#x2F;*SQL对⼤⼩写不敏感*&#x2F;\n(empid char(9) PRIMARY KEY,\nidno char(18) UNIQUE,\nname char(8) NOT NULL,\ngender bit NOT NULL,\nphone char(20),\ndeptid int NULL\n);\n\n\n\n\n\n\n\n\n\n\nNote that there is no cognominal(同名的) tables in a DB\n\nModifying Relation Schemas\n\nALTER TABLE ADD column-name datatype NULL；\n增加一列\nALTER TABLE DROP column-name;\n删除一列\nALTER TABLE tablename RENAME TO newname;\n改表名\nDROP TABLE tablename;\n删除表\n\n\nDefault Values\n\nWhen we create or modify tuples, we  sometimes do not  have values for all components.\nSQL provides the NULL value as default value. (隐含默认NULL)\n When we declare an attribute and its data type, we may add the keyword &#x3D;&#x3D;DEFAULT&#x3D;&#x3D; and &#x3D;&#x3D;an appropriate value&#x3D;&#x3D;.\ngender CHAR(1) DEFAULT “？”\n\n\nDeclaring Keys\n\n声明某⼀属性(⾮多属性)为“键”：在属性被列入关系时就声明。\ndeptid  int    PRIMARY KEY,\n\n如果声明一组(一个及以上)属性为键需要:\nPRIMARY KEY (orderno, lineno)\n\n\nPrimary Key and Unique\n\n\n\n\n\n\n\n\n\n\nAtable has and only has one Primary Key, (键只能声明⼀次)，while it may has any number of Unique declarations.\n1、Primary key的1个或多个列必须为NOT NULL，如果列为NULL，在增加PRIMARY KEY时，列自动更改为NOT NULL。而UNIQUE KEY 对列没有此要求。\n2、一个表只能有一个PRIMARY KEY，但可以有多个UNIQUE KEY。\n1.3.An Algebraic Query Language关系代数的表达式称为查询（query）\nOperands &#x2F;操作数are relations or variables \nOperators &#x2F;操作符号are symbols denoting\n1.3.1.传统关系代数分类\nThe usual set operations: union, intersection and difference (关系：并、交、差)\n\nOperations that remove parts of a relation:\nSelection: eliminates(消除) some rows (tuples)按条件选取行\n\n\n​      Projection(投影): eliminates some colunms (attributes)选列\n\nOperations that combine(组合联接) the tuples of two relations\n\n​       Cartesian  product(笛卡尔积)：将两个关系的所有可能配对形成新关系。\n​       Join(连接):\n​         Natural join ⾃然联接\n​         Theta-join θ联接\n\nRenaming改名:不影响关系中的元组但是改变了关系中的模式\n\n1.3.2.Set Operations on Relations集合操作\n\n\n\n\n\n\n\n\n\n注意集合操作前，需要各个属性相同，否则需要重命名\n1.3.3.Projection 选属性","slug":"Database Note","date":"2022-04-18T15:03:46.000Z","categories_index":"","tags_index":"database","author_index":"赫"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"安装MySQL下载安装包：下载网址：https://dev.mysql.com/downloads/\n\n安装添加环境变量\n\n我的电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量\n\n选择Path-&gt;编辑-&gt;新建，添加：你的mysql安装文件下的bin文件夹地址\n\n在安装目录下新建my.ini文件（文本文档）\n\n编辑my.ini文件，注意替换你自己电脑上的路径\n\n\n[mysqld]\nbasedir &#x3D; D:\\environment\\mysql-5.7.31\\  &#x2F;&#x2F;把这两行路径改成自己的安装路径\ndatadir &#x3D; D:\\environment\\mysql-5.7.31\\data\\\nport &#x3D; 3306\nskip-grant-tables\n\n\n\n启动cmd(用管理员身份)\nmysqld -install\nmysqld --initialize-insecure --user&#x3D;mysql\n\n这步完成后，在文件夹里会生成一个data文件（如果没有就自己加一个）\n\n\n完成后会显示MySQL 服务已经启动成功\n然后通过命令mysql -u root -p，进入mysql管理界面（密码为空）\nALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;111111&#39;;\n\n输入exit 退出\n","slug":"安装MySQL","date":"2022-04-18T11:53:32.082Z","categories_index":"","tags_index":"","author_index":"赫"}]